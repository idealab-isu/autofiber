Problems I have found:
Missing CADSupport.py:
	If I build the project in visual studio for the first time with the Debug version then the CADSupport.py file is missing
	Workaround:
		Switch to Release version before building for the first time


Integration with de-la-mo

https://www.sharcnet.ca/Software/Abaqus/6.14.2/v6.14/books/ker/default.htm

Possible integration points:
    api.py - line: 1020
        Define MaterialOrientation with results of geodesic code
            MaterialOrientation() - Property Commands
                - fieldname
                    DiscreteField() - Field Commands
                        - data
                            DataTable() - Field Commands
                                - domain: A tuple of Ints specifying the domain node, element or integration point identifiers.
                                - table: A tuple of Floats specifying the data within the domain.


function [x] = conjgrad(A, b, x)
    r = b - A * x;
    p = r;
    rsold = r' * r;

    for i = 1:length(b)
        Ap = A * p;
        alpha = rsold / (p' * Ap);
        x = x + alpha * p;
        r = r - alpha * Ap;
        rsnew = r' * r;
        if sqrt(rsnew) < 1e-10
              break;
        end
        p = r + (rsnew / rsold) * p;
        rsold = rsnew;
    end
end

sys.modules["__main__"].__dict__.update(globals())
sys.modules["__main__"].__dict__.update(locals())
raise ValueError()

def minor(arr, i, j):
    # https://stackoverflow.com/questions/3858213/numpy-routine-for-computing-matrix-minors
    # ith row, jth column removed
    return ((-1) ** (i + j)) * arr[:, np.array(range(i)+range(i+1, arr.shape[1]))[:, np.newaxis],
                               np.array(range(j)+range(j+1, arr.shape[2]))]


E = 200.0
nu = 0.3
G = E / (2 * (1 + nu))
compliance_tensor = np.array([[1 / E, -nu / E, 0],
                              [-nu / E, 1 / E, 0],
                              [0, 0, 1 / G]])

stiffness_tensor2d = np.linalg.inv(compliance_tensor)

compliance_tensor = np.array([[1 / E, -nu / E, -nu / E, 0, 0, 0],
                                   [-nu / E, 1 / E, -nu / E, 0, 0, 0],
                                   [-nu / E, -nu / E, 1 / E, 0, 0, 0],
                                   [0, 0, 0, 1 / G, 0, 0],
                                   [0, 0, 0, 0, 1 / G, 0],
                                   [0, 0, 0, 0, 0, 1 / G]])

stiffness_tensor3d = np.linalg.inv(compliance_tensor)

vertexids2d = np.array([[0, 1, 2]])

vertices2d_un = np.array([[0, 0],
                          [1, 1],
                          [2, 0]], dtype=np.float)

vertices2d = vertices2d_un.flatten()

fiberpoints2d_un = np.array([[0, 0],
                             [1, 2],
                             [2, 0]], dtype=np.float)

fiberpoints2d = fiberpoints2d_un.flatten()


# def strainenergy(normalized_2d, fiberpoints, vertexids, stiffness_tensor):
#     element_vertices_2d = normalized_2d.reshape(normalized_2d.shape[0] / 2, 2)[vertexids]
#     element_vertices_uv = fiberpoints.reshape(fiberpoints.shape[0]/2, 2)[vertexids]
#
#     centroid_2d = np.sum(element_vertices_2d, axis=1) / 3
#     centroid_uv = np.sum(element_vertices_uv, axis=1) / 3
#
#     rel_uv = np.subtract(element_vertices_uv, centroid_uv[:, np.newaxis])
#     rel_uv = np.pad(rel_uv, [(0, 0), (0, 0), (0, 1)], "constant", constant_values=1)
#     rel_2d = np.subtract(element_vertices_2d, centroid_2d[:, np.newaxis])
#
#     invrel_uv = np.linalg.inv(rel_uv)
#     deform_mat = np.matmul(invrel_uv, rel_2d)[:2, :2]
#
#     # https://en.wikipedia.org/wiki/Infinitesimal_strain_theory
#     # deform_mat = deform_mat + np.identity(deform_mat.shape[1])
#     # strain = 0.5 * (np.transpose(deform_mat, (0, 2, 1)) + deform_mat) - np.identity(deform_mat.shape[1])
#     # Finite strain theory
#     # https://www.klancek.si/sites/default/files/datoteke/files/derivativeofprincipalstretches.pdf
#     strain = 0.5 * (np.matmul(np.transpose(deform_mat, (0, 2, 1)), deform_mat) - np.identity(deform_mat.shape[1]))
#
#     m = np.array([1, 1, 0.5])[np.newaxis].T
#     strain_vector = np.divide(np.array([[strain[:, 0, 0]], [strain[:, 1, 1]], [strain[:, 0, 1]]]).transpose((2, 0, 1)), m).squeeze()[np.newaxis]
#
#     # http://homepages.engineering.auckland.ac.nz/~pkel015/SolidMechanicsBooks/Part_I/BookSM_Part_I/08_Energy/08_Energy_02_Elastic_Strain_Energy.pdf
#     stress = np.einsum('ij,ej->ei', stiffness_tensor, strain_vector)
#     strain_energy_density = 0.5 * (np.einsum('ei,ei->e', stress, strain_vector))
#
#     # sys.stdout.write('Strain Energy Density: %f       \r' % (np.sum(strain_energy_density),))
#     # sys.stdout.flush()
#     # pdb.set_trace()
#     print(np.sum(strain_energy_density))
#     return np.sum(strain_energy_density)
#
#
# def strainenergygrad(normalized_2d, fiberpoints, vertexids, stiffness_tensor):
#     element_vertices_2d = normalized_2d.reshape(normalized_2d.shape[0] / 2, 2)[vertexids]
#     element_vertices_uv = fiberpoints.reshape(fiberpoints.shape[0]/2, 2)[vertexids]
#
#     centroid_2d = np.sum(element_vertices_2d, axis=1) / 3
#     centroid_uv = np.sum(element_vertices_uv, axis=1) / 3
#
#     rel_uv = np.subtract(element_vertices_uv, centroid_uv[:, np.newaxis])
#     rel_uv = np.pad(rel_uv, [(0, 0), (0, 0), (0, 1)], "constant", constant_values=1)
#     rel_2d = np.subtract(element_vertices_2d, centroid_2d[:, np.newaxis])
#
#     invrel_uv = np.linalg.inv(rel_uv)
#     F = np.matmul(invrel_uv, rel_2d)[:2, :2]
#
#     dF_du = np.zeros((F.shape[0], 4, 2, 2))
#     for i in range(0, dF_du.shape[2]):
#         for j in range(0, dF_du.shape[3]):
#             k = i*dF_du.shape[2] + j
#             dF_du[:, k, i, j] = F[:, i, j]
#
#     # https://en.wikipedia.org/wiki/Infinitesimal_strain_theory
#     # deform_mat = deform_mat + np.identity(deform_mat.shape[1])
#     # strain = 0.5 * (np.transpose(deform_mat, (0, 2, 1)) + deform_mat) - np.identity(deform_mat.shape[1])
#     # Finite strain theory
#     # https://www.klancek.si/sites/default/files/datoteke/files/derivativeofprincipalstretches.pdf
#     strain = 0.5 * (np.matmul(np.transpose(F, (0, 2, 1)), F) - np.identity(F.shape[1]))
#
#     m = np.array([1, 1, 0.5])[np.newaxis].T
#     strain_vector = np.divide(np.array([[strain[:, 0, 0]], [strain[:, 1, 1]], [strain[:, 0, 1]]]).transpose((2, 0, 1)), m).squeeze()[np.newaxis]
#
#     dE_dstrain = 0.5 * (np.einsum('ij,ej->ei', stiffness_tensor, strain_vector) + np.einsum('ei,ij->ej', strain_vector, stiffness_tensor))
#
#     dstrain_du = 0.5 * (np.matmul(np.transpose(dF_du, (0, 1, 3, 2)), F) + np.matmul(np.transpose(F, (0, 2, 1)), dF_du))
#
#     dstrain_vector_du = np.divide(np.array([[dstrain_du[:, :, 0, 0]], [dstrain_du[:, :, 1, 1]], [dstrain_du[:, :, 0, 1]]]).transpose((2, 3, 0, 1)), m).squeeze()[np.newaxis]
#
#     dE_du = np.einsum('eij,ej->ei', dstrain_vector_du, dE_dstrain).reshape(dstrain_vector_du.shape[0], 3, 2)
#
#     point_strain_grad = np.zeros((fiberpoints.shape[0]/2, 2))
#     for i in range(0, vertexids.shape[0]):
#         ele_vertices = vertexids[i]
#         ele_strain_grad = dE_du[i]
#         pdb.set_trace()
#         point_strain_grad[ele_vertices] = point_strain_grad[ele_vertices] + ele_strain_grad
#     return point_strain_grad.flatten()


def computeglobalstrain(normalized_2d, fiberpoints, vertexids, stiffness_tensor):
    element_vertices_uv = fiberpoints.reshape(fiberpoints.shape[0]/2, 2)[vertexids]

    centroid_2d = np.sum(normalized_2d, axis=1) / 3
    centroid_uv = np.sum(element_vertices_uv, axis=1) / 3

    rel_uv = np.subtract(element_vertices_uv, centroid_uv[:, np.newaxis])
    rel_2d = np.subtract(normalized_2d, centroid_2d[:, np.newaxis]).reshape(element_vertices_uv.shape[0], 6)

    C = np.array([[rel_uv[:, 0, 0], rel_uv[:, 0, 1], np.ones(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0])],
                  [np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), rel_uv[:, 0, 0], rel_uv[:, 0, 1], np.ones(rel_uv.shape[0])],
                  [rel_uv[:, 1, 0], rel_uv[:, 1, 1], np.ones(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0])],
                  [np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), rel_uv[:, 1, 0], rel_uv[:, 1, 1], np.ones(rel_uv.shape[0])],
                  [rel_uv[:, 2, 0], rel_uv[:, 2, 1], np.ones(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0])],
                  [np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), rel_uv[:, 2, 0], rel_uv[:, 2, 1], np.ones(rel_uv.shape[0])]]).transpose((2, 0, 1))

    Ci = np.repeat(C[:, np.newaxis, :, :], rel_2d.shape[1], axis=1)

    for i in range(0, rel_2d.shape[1]):
        Ci[:, i][:, :, i] = rel_2d

    detC = np.linalg.det(C)
    detCi = np.linalg.det(Ci).T

    b = (detCi/detC).T

    B = np.array([[b[:, 0], b[:, 1], b[:, 2]],
                  [b[:, 3], b[:, 4], b[:, 5]],
                  [np.zeros(b.shape[0]), np.zeros(b.shape[0]), np.zeros(b.shape[0])]]).transpose((2, 0, 1))

    deform_mat = B
    # https://en.wikipedia.org/wiki/Infinitesimal_strain_theory
    # strain = 0.5 * (np.transpose(deform_mat, (0, 2, 1)) + deform_mat) - np.identity(B.shape[1])
    # Finite strain theory
    # https://www.klancek.si/sites/default/files/datoteke/files/derivativeofprincipalstretches.pdf
    strain = 0.5 * (np.matmul(np.transpose(deform_mat, (0, 2, 1)), deform_mat) - np.identity(B.shape[1]))

    m = np.array([1, 1, 1, 0.5, 0.5, 0.5])[np.newaxis].T
    strain_vector = np.divide(np.array([[strain[:, 0, 0]], [strain[:, 1, 1]], [strain[:, 2, 2]], [strain[:, 1, 2]], [strain[:, 0, 2]], [strain[:, 0, 1]]]).transpose((2, 0, 1)), m).squeeze()[np.newaxis]

    # http://homepages.engineering.auckland.ac.nz/~pkel015/SolidMechanicsBooks/Part_I/BookSM_Part_I/08_Energy/08_Energy_02_Elastic_Strain_Energy.pdf
    stress = np.einsum('ij,ej->ej', stiffness_tensor, strain_vector)
    strain_energy_density = 0.5 * (np.einsum('ei,ei->e', stress, strain_vector))

    # sys.stdout.write('Strain Energy Density: %f       \r' % (np.sum(strain_energy_density),))
    # sys.stdout.flush()
    # print(np.sum(strain_energy_density))
    # pdb.set_trace()
    return np.sum(strain_energy_density)


def computeglobalstrain_grad(normalized_2d, fiberpoints, vertexids, stiffness_tensor):
    mask = np.array([[0, 9],
                     [1, 10],
                     [12, 21],
                     [13, 22],
                     [24, 33],
                     [25, 34]])

    element_vertices_uv = fiberpoints.reshape(fiberpoints.shape[0]/2, 2)[vertexids]

    centroid_2d = np.sum(normalized_2d, axis=1) / 3
    centroid_uv = np.sum(element_vertices_uv, axis=1) / 3

    rel_uv = np.subtract(element_vertices_uv, centroid_uv[:, np.newaxis])
    rel_2d = np.subtract(normalized_2d, centroid_2d[:, np.newaxis]).reshape(element_vertices_uv.shape[0], 6)

    C = np.array([[rel_uv[:, 0, 0], rel_uv[:, 0, 1], np.ones(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0])],
                  [np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), rel_uv[:, 0, 0], rel_uv[:, 0, 1], np.ones(rel_uv.shape[0])],
                  [rel_uv[:, 1, 0], rel_uv[:, 1, 1], np.ones(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0])],
                  [np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), rel_uv[:, 1, 0], rel_uv[:, 1, 1], np.ones(rel_uv.shape[0])],
                  [rel_uv[:, 2, 0], rel_uv[:, 2, 1], np.ones(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0])],
                  [np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), np.zeros(rel_uv.shape[0]), rel_uv[:, 2, 0], rel_uv[:, 2, 1], np.ones(rel_uv.shape[0])]]).transpose((2, 0, 1))

    rel_uv = rel_uv.reshape(rel_uv.shape[0], 6)

    db_du = np.empty((rel_2d.shape[0], 6, 6))
    # Calculate each bi
    Ci = np.repeat(C[:, np.newaxis, :, :], rel_2d.shape[1], axis=1)

    for i in range(0, rel_2d.shape[1]):
        Ci[:, i][:, :, i] = rel_2d

    detC = np.linalg.det(C)
    detCi = np.linalg.det(Ci).T

    b = (detCi/detC).T

    for i in range(0, rel_uv.shape[1]):
        C_i = Ci[:, i, :, :]
        # Calculate the derivative of the current bi relative to each cij
        for j in range(0, rel_uv.shape[1]):
            cij_indx = mask[j]

            ddetci_dcij = 0
            ddetc_dcij = 0
            for k in range(0, cij_indx.shape[0]):
                unwrapped = np.asarray(np.unravel_index(cij_indx[k], (C.shape[1], C.shape[2]))).T

                # d(det(C))/d(c_ij)
                if unwrapped[1] != i:
                    ddetci_dcij += np.linalg.det(minor(C_i, unwrapped[0], unwrapped[1]))

                # d(det(C))/d(c_ij)
                ddetc_dcij += np.linalg.det(minor(C, unwrapped[0], unwrapped[1]))

            # d(b_ij)/d(c_ij)
            db_du[:, i, j] = (ddetci_dcij * detC - detCi[i, :] * ddetc_dcij)/(detC ** 2)

    db_du = db_du.transpose(0, 2, 1).reshape(db_du.shape[0], 6, 2, 3)
    db_du = np.pad(db_du, [(0, 0), (0, 0), (0, 1), (0, 0)], "constant", constant_values=0)

    # Calculate dE/dstrain
    B = np.array([[b[:, 0], b[:, 1], b[:, 2]],
                  [b[:, 3], b[:, 4], b[:, 5]],
                  [np.zeros(b.shape[0]), np.zeros(b.shape[0]), np.zeros(b.shape[0])]]).transpose((2, 0, 1))

    deform_mat = B
    # Infinitesimal theory
    # strain = 0.5 * (np.transpose(deform_mat, (0, 2, 1)) + deform_mat) - np.identity(B.shape[1])
    # Finite theory
    strain = 0.5 * (np.matmul(np.transpose(deform_mat, (0, 2, 1)), deform_mat) - np.identity(B.shape[1]))

    m = np.array([1, 1, 1, 0.5, 0.5, 0.5])[np.newaxis].T
    strain_vector = np.divide(np.array([[strain[:, 0, 0]], [strain[:, 1, 1]], [strain[:, 2, 2]], [strain[:, 1, 2]], [strain[:, 0, 2]], [strain[:, 0, 1]]]).transpose((2, 0, 1)), m).squeeze()[np.newaxis]
    dE_dstrain = np.einsum('ij,ej->ej', stiffness_tensor, strain_vector)

    # Calculate dstrain/du
    # Infinitesimal
    # dstrain_du = 0.5 * (np.transpose(db_du, (0, 1, 3, 2)) + db_du)
    # Finite theory dstrain/du
    dstrain_du = 0.5 * (np.matmul(np.transpose(db_du, (0, 1, 3, 2)), deform_mat[:, np.newaxis, :, :]) + np.matmul(
        np.transpose(deform_mat, (0, 2, 1))[:, np.newaxis, :, :], db_du))

    dstrain_vector_du = np.divide(np.array([[dstrain_du[:, :, 0, 0]], [dstrain_du[:, :, 1, 1]], [dstrain_du[:, :, 2, 2]], [dstrain_du[:, :, 1, 2]], [dstrain_du[:, :, 0, 2]], [dstrain_du[:, :, 0, 1]]]).transpose((2, 3, 0, 1)), m).squeeze()[np.newaxis]

    dE_du = np.einsum('eij,ej->ei', dstrain_vector_du, dE_dstrain).reshape(dstrain_vector_du.shape[0], 3, 2)

    point_strain_grad = np.zeros((fiberpoints.shape[0]/2, 2))
    for i in range(0, vertexids.shape[0]):
        ele_vertices = vertexids[i]
        ele_strain_grad = dE_du[i]

        point_strain_grad[ele_vertices] = point_strain_grad[ele_vertices] + ele_strain_grad
    return point_strain_grad.flatten()


def f(x, *args):
    return computeglobalstrain(vertices2d_un[vertexids2d], x, vertexids2d, stiffness_tensor3d)


def grad(x, *args):
    return computeglobalstrain_grad(vertices2d_un[vertexids2d], x, vertexids2d, stiffness_tensor3d)


# res = optimize.minimize(f, fiberpoints2d, jac=grad, method="CG", options={'gtol': 1e-8})
#
# fres = res.x.reshape(fiberpoints2d_un.shape)
#
# fig = plt.figure()
#
# plt.scatter(vertices2d_un[:, 0], vertices2d_un[:, 1], color='b')
# t1 = plt.Polygon(vertices2d_un, color='b', fill=False)
# plt.gca().add_patch(t1)
#
# plt.scatter(fiberpoints2d_un[:, 0], fiberpoints2d_un[:, 1], color='r')
# t2 = plt.Polygon(fiberpoints2d_un, color='r', fill=False)
# plt.gca().add_patch(t2)
#
# plt.scatter(fres[:, 0], fres[:, 1], color='g')
# t3 = plt.Polygon(fres, color='g', fill=False)
# plt.gca().add_patch(t3)
#
# sys.modules["__main__"].__dict__.update(globals())
# sys.modules["__main__"].__dict__.update(locals())
# raise ValueError()
